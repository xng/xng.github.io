[{"title":"java.lang.NoSuchMethodError","url":"/2017/05/13/java-lang-nosuchmethoderror/","content":"\n的最近项目启动遇到一个问题，完整报错信息如下：\n```java\nContext initialization failed\n\njava.lang.NoSuchMethodError: org.springframework.beans.factory.support.DefaultListableBeanFactory.getDependencyComparator()Ljava/util/Comparator;\n```\n \n\nDefaultListableBeanFactory找不到这个方法getDependencyComparator,先查找这个类到底有没有这个方法，发现这个类出现在两个包里，如下\n\n ![](http://www.dacai.me/wp-content/uploads/2017/03/nosuchMethod-1024x138.png) 分别是spring4.*和spring2.*，很明显是jar包冲突的问题了，一个版本里面有这个方法，另一个没有，把没有的那个版本，一般是低版本，排除掉，再启动，ok了，还有个坑就是这个问题本地用jetty起一直没报出来，上了服务器是tomcat就出来了，可能是择包的机制不一样吧。","tags":["排错"],"categories":["java"]},{"title":"node.js入门","url":"/2017/03/21/getting-started-with-node-js/","content":"\nnodejs是什么？ nodejs并不是一门新的语言，Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 谷歌V8又是什么？ V8 是 Google 发布的开源 JavaScript 引擎，采用 C++ 编写，在 Google 的 浏览器中被使用。V8 引擎可以独立运行，也可以用来嵌入到 C++ 应用程序中执行，简单的说就是nodejs是一个JavaScript运行环境，可以让JavaScript运行在服务端，而不是局限于浏览器。依靠谷歌V8引擎解释和执行JavaScript。同时nodejs提供了很多模块，比如http模块，文件读写模块，所以nodejs也是一个库。架构大概如下图 \n<!-- more -->\n![](http://www.dacai.me/wp-content/uploads/2017/03/屏幕快照-2017-03-21-下午4.22.10-1024x519.png) 除了使 用 V8 作为JavaScript引擎以外，对不同系统抽象出中间层libuv，实现高性能的异步I/O访问。 为什么使用nodejs? 前面说了nodejs是一个使用了事件驱动，非阻塞式I/O模型，什么非阻塞式I/O模型？ 什么是阻塞，什么是非阻塞？ 阻塞就是你给114打电话问个电话号码，114说你先别挂，等我给你查下，这时候你拿着电话不能去干别的，只能等他查，然后一段时间后告诉你电话号码是啥啥啥？这里你问电话相当于占用了cpu计算，但查电话只是查数据库，有I/O的耗时等待，但并不占用cpu计算，但是呢，你这个cpu现在想去干个别的干不了，还得等这个I/O结束，这就是阻塞，比如Java。非阻塞呢。你给114打电话，114说好的您挂了吧，我查到后告诉你，这时候你可以去干别的了。I/O查询并没有阻塞你，而是I/O（电话）准备好后再通知你,这就是非阻塞。 显而易见非阻塞更合理，就一个单线程，不断的跑计算，遇到io就异步执行，io完成后再继续，但阻塞式编程可以通过多线程去优化，两者流程大概如下: ![](http://www.dacai.me/wp-content/uploads/2017/03/屏幕快照-2017-03-21-下午4.42.50-1024x718.png) 其实效率差不多，但多线程每个线程都要分配一定的内存，而且我们都知道Java Tomcat是有链接数限制的，异步I/O减少了多线程中创建线程、分配内存、列入调度、切换线程、内存换页、CPU缓存等方面的开销。这个并不是说多线程就不好，各有各的好处吧，如果涉及到大量计算，单线程的cpu会一直被计算占用很难开辟时间去发起I/O操作了。 事件驱动又是怎么回事，上面说的单线程的处理方式其实就是用的事件循环，当执行完计算1后，异步执行了I/O,那cpu知道什么时候继续执行计算2呢，这里看下nodejs的事件循环： ![](http://www.dacai.me/wp-content/uploads/2017/03/屏幕快照-2017-03-21-下午4.53.06-1024x526.png) nodejs有一个事件队列，然后又一个循环不断的遍历这个队列，里面有事件就去执行，首先计算1是一个事件， 在事件队列里发现后去执行，然后发起了I/O,I/O结束后又会塞一个计算2的事件到事件队列里，再循环的时候就遍历到了，然后执行。 说了这么多，动手试试： 首先要先按钮nodejs，官网自己下载。直接新建个hello.js文件，直接写js就可以。比如在里面写\n\n`console.log(‘hello world’)。`\n\n控制台用node去执行，node hello.js控制台就会打印出hello world。下面来个复杂点的:\n```js\nfunction cal1() {\n    console.log(\"计算1\")\n    callIO(cal2)\n}\n\nfunction cal2(data) {\n    console.log(\"计算2结果是\" + data)\n}\n\nfunction callIO(callback) {\n    console.log(\"IO操作\")\n    setTimeout(function () {\n        console.log(\"IO操作完成查到data是123\")\n        var data = 123;\n        if (callback) {\n            callback(data);\n        }\n    }, 1000)\n}\ncal1()\n```\n还原了刚才说的计算1--IO--计算2的过程 分析下，执行计算1，中间需要处理I/O了，可能去数据库查了个数据，或者是磁盘读了个文件，也可能是发了个HTTP请求，setTimeOut会js的都明白，这里假装耗时了1秒才完成，执行IO完成后通过IO查到了一个需要计算的data是123，传给计算2去执行计算2，这时候计算2这个事件是调I/O方法时传进来的，这样IO执行完后就把这个事件（计算2）放到了事件队列去执行了。打印如下：\n\n计算1\nIO操作\nIO操作完成查到data是123\n计算2结果是123\n\n之前有人误解说nodejs是单线程的，那哪来的线程去执行IO等操作呢，其实nodejs的单线程是说你写的代码是单线程的，nodejs除了有一个线程去执行你的代码，碰到IO操作会有一个线程池去专门处理这些IO，处理代码的事件循环可以算做主线程。 现在nodejs的基本框架理清了，看下他有哪些常用的API，nodejs有个包管理器，类似Java有个maven库，可以通过pom.xml下载依赖的jar包，配置打包流程等，nodejs也有这么个东西，就是npm，通过配置package.json配置nodejs需要的模块，应用的名字，版本，执行方法等。如下一个例子:\n```json\n{\n    \"name\": \"forever\",\n    \"preferGlobal\": \"true\",\n    \"description\": \"A simple CLI tool for ensuring that a given node script runs continuously (i.e. forever)\",\n    \"version\": \"0.15.3\",\n    \"author\": \"Charlie Robbins <charlie.robbins@gmail.com>\",\n    \"maintainers\": [\n        \"mmalecki <me@mmalecki.com>\",\n        \"avianflu <charlie@charlieistheman.com>\"\n    ],\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/foreverjs/forever.git\"\n    },\n    \"keywords\": [\n        \"cli\",\n        \"fault tolerant\",\n        \"sysadmin\",\n        \"tools\"\n    ],\n    \"dependencies\": {\n        \"cliff\": \"~0.1.9\",\n        \"clone\": \"^1.0.2\",\n        \"colors\": \"~0.6.2\",\n        \"flatiron\": \"~0.4.2\",\n        \"forever-monitor\": \"~1.7.0\",\n        \"nconf\": \"~0.6.9\",\n        \"nssocket\": \"~0.5.1\",\n        \"object-assign\": \"^3.0.0\",\n        \"optimist\": \"~0.6.0\",\n        \"path-is-absolute\": \"~1.0.0\",\n        \"prettyjson\": \"^1.1.2\",\n        \"shush\": \"^1.0.0\",\n        \"timespan\": \"~2.3.0\",\n        \"utile\": \"~0.2.1\",\n        \"winston\": \"~0.8.1\"\n    },\n    \"devDependencies\": {\n        \"broadway\": \"~0.3.6\",\n        \"eventemitter2\": \"0.4.x\",\n        \"request\": \"2.x.x\",\n        \"vows\": \"0.7.x\"\n    },\n    \"bin\": {\n        \"forever\": \"./bin/forever\"\n    },\n    \"main\": \"./lib/forever\",\n    \"scripts\": {\n        \"test\": \"vows test/**/*-test.js --spec -i\"\n    },\n    \"engines\": {\n        \"node\": \">= 0.8.x\"\n    },\n    \"license\": \"MIT\"\n}\n```\n这是nodejs众多开发者上传的npm包中的一个叫forever的包的package.json，用来后台运行nodejs应用。看键值就应该明白这个package.json介绍了这个包的名字，版本号，作者，git地址，main方法，依赖的其他包，依赖的nodejs引擎版本还有开源类型。如果你想用这个包，直接npm install forever就行了，node除了开发者上传的包外，自身提供了很多基础的包，比如nodejs内置了http服务器，可以不依赖Tomcat等容器就能启动web服务，如下代码就能启动一个简单的web应用:\n```js\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) => {\n    res.statusCode = 200;\n    res.setHeader('Content-Type', 'text/plain');\n    res.end('Hello World\\\\n');\n});\n\nserver.listen(port, hostname, () => {\n    console.log(`服务器运行在 http://${hostname}:${port}/`);\n});\n```\n是不是很简单，还有fs文件处理，path路径处理，url链接处理，util工具等包，参考nodejs中文API:http://nodejs.cn/api/ 说了这么多，nodejs适合做什么呢，通过前面介绍他的优缺点可以看出，nodejs适合做高并发，低IO，低计算的应用，比如网络爬虫，实时聊天，前后端分离的应用。不适合做密集型CPU的应用。大概就是这些，后续再补充","tags":["node"],"categories":["node"]},{"title":"程序员用Mac推荐APP","url":"/2017/01/23/recommended-programmer-mac-app/","content":"\n不得不说，mac真的是编程利器，如果你不是做window软件开发，不需要玩儿lol等pc游戏，果断用mac吧，基于Unix的操作系统，各种Linux的命令grep,make,top,ssh等都可以直接使用，安全，快速，免除各种驱动烦恼，免除各种安全卫士，精美的设计，当然还有一堆非常好用的app\n<!-- more -->\n#### iTerm\n\n比Terminal好用的终端，包括选中即复制，command + ;  自动补全命令;command + shift +h 历史命令记录，类似history；智能识别网址，邮箱；tap自动修正等，谁用谁知道；\n\n#### Quiver\n\n适合程序员的笔记软件，可以设置代码格式高亮，格式化等。如图 ![](http://www.dacai.me/wp-content/uploads/2017/01/JsonEx.gif) 另外支持markdown\n\n#### Cornerstone\n\nsvn客户端工具\n\n#### SourceTree\n\nGit客户端工具\n\n#### iHosts\n\n方便的host切换工具，调试开发必备![](http://www.dacai.me/wp-content/uploads/2017/01/ihostsEx.png)\n\n#### QuickMenu\n\n方便打开常用目录，可以设置快捷键，在鼠标附近展开菜单，方便点击 ![](http://www.dacai.me/wp-content/uploads/2017/01/quickmenuEx.gif)\n\n#### Sip\n\n  比如我是做前端开发，就用Css Hex取色结果是16进制的颜色码，自动复制到剪贴板，如果做Android开发，选择Android RGB，取色结果就是Color.rgb(35, 40, 45);可以直接在Android使用的颜色代码。Swift UIColor模式结果便是UIColor(red:0.14, green:0.16, blue:0.18, alpha:1.00);非常方便。\n\n#### Snip\n\n腾讯出的一个小工具，支持简单的编辑，非常好用。![](http://www.dacai.me/wp-content/uploads/2017/01/snipEx-300x260.png)\n\n#### Copied\n\n保持复制记录，免去重复复制粘贴。包括复制过的图片都有记录![](http://www.dacai.me/wp-content/uploads/2017/01/copiedEx-683x1024.png)\n\n#### FilleZilla\n\nFTP连接工具\n\n#### Sequal Pro\n\nmysql图形管理工具 等等大概就是这些，其他的IDEA，Sublime Text，Chrome等开发必备的app就不说了，放弃Eclipse吧。。","categories":["工具"]},{"title":"程序员如何提高工作效率","url":"/2017/01/22/programmers-how-to-improve-work-efficiency/","content":"\n最近换了换工作了，来到一个国内比较知名的公司，工作两个月后明显感觉到自己之前的不足，这边公司工作不太看重过程，而是看结果，你说作为一个程序员，天天加班来加班去的，不管你多累，没有一个好结果，没用！这里就要想到一个问题，如何提高工作效率？以下是我入职两个月来的工作总结，互利共勉。\n\n#### 不做搬砖工\n\n之前来需求，总是人家产品说什么就做什么，一切代码按设计来，一点自己的想法没有，听之任之，回头儿做出一个版本来，产品可能没考虑到实现后的一些问题，又提出要改，这时离上线还有两天了，加班吧！改来改去，感觉身体被掏空，虽然做了很多工作，对结果却没有加成，失败。总结，一定要学会PK,产品来了需求，要打着不做的想法去PK(当然不是为了偷懒)。想一想各种不适合这个需求的场景，提出来，如果能pk过产品，ok，让他去改，改的更合理再做，如果pk不过，那说明需求还算合理，做吧。\n\n#### 多做笔记\n\n俗话说好记性不如烂笔头，可能会议记录说了些业务上的事情，你当时缕清了，感觉没难度，过两天开发时，突然又不确定这个流程了，还得跑去找PM问，浪费大家的宝贵时间，所以一定要做好笔记，不管多简单的东西，都记录下来，推荐有道云笔记，mac用户推荐一个软件Quiver，程序员专用。\n\n#### 理清需求\n\n来了需求，一定要先梳理清楚再写代码，不要边写边看PRD,弄清楚业务来龙去脉还有细节，比如做个接口，谁来调，怎么调，传递什么参数，一定要提前沟通好，其实每天的工作，写代码的时间很少，大部分时间都在碰需求。需求梳理清楚了，写代码如尿崩分分钟搞定的事情。\n\n#### 磨刀工\n\n跟上面缕清需求有点类似，这次是写代码前先弄清代码。什么意思，我还没写呢弄清什么代码？是说你来了一个公司，可能人家的项目已经在运行了，你只是在之前的项目上添加功能，每个项目的框架结构可能不一样。前端的，后端的，一定要弄清楚之前的代码再在上面添加修改。不要觉得他这是这么用的能跑通，我直接复制过来改吧改吧改成我的也能跑通的。这种没弄清代码什么意思就复制粘贴过来隐患最大，千万不要图省事。\n\n#### 授人以渔\n\n工作中免不了有新人来请教问题，大家都是新人走过了的，互相帮助是应该的，不过不要有什么问题就直接拿过来调试，或者直接替他写，这样他还是没学会，下次同样的问题还是来找你，应该是指明一个思路，让他自己多想想。这样即让他对这样的问题也增长了经验，也不太耽误自己的工作时间。\n\n#### 不拖延\n\n有时分了个任务，自己评估1天就能搞定，给了3天的工期，后面也没啥事，最近又比较累，想想今天就上上网，聊聊天。休息一天吧，这是万万不可取的，有任务，有时间一定要提前完成。计划赶不上变化，你评估的1天有可能3天都玩不成，或者第二天又有个着急的任务扔给你，这时候就要紧张了，提前完成如果后面又有任务可以从容应付，没有新任务想休息下也可以放心休息了。\n\n#### 分轻重\n\n开发过程中避免不了遇到各种问题，调试呗，结果为了解决一个小问题调试了一整天，可能调通了，不过这一天就这么浪费了，任务可能还延期了，其实可以这样，有问题，先评估这个问题的轻重，如果不是特别重要，不影响后续的开发，先做主要的事情，回头儿开发完成再来调试，这样不耽误主要的任务进度，如果这个问题解不了后面没法开发，评估一下自己大概多久能解决，如果自己压根儿没思路，就请教请教同事好了，虽然大家都很忙。如果想自己试试，查资料调了半个小时还是没啥进展，还是问问别人吧，不要把一天都浪费在调试上。除了这个我还有选择强迫症，遇到两个框架都能用时就得纠结半天要用哪个。在网上搜罗半天各种分析文章，其实没啥必要，白耽误时间。不要拣了芝麻丢了西瓜。\n\n#### 单元测试\n\nDAO接口一定要写单元测试，Service接口有时间的话也写一写，maven打包不要跳过test。团队最好有代码review的习惯，没有的话就找个同事互相review代码。\n\n#### 学习充电\n\n如果你像我一样是一个屌丝，家里也没什么背景，别的行业又不感兴趣，励志做一个优秀的程序员，那就抓紧每一分每一秒去学习吧，这个行业真是有学不完的东西，有空闲的时间就看看书，下班回家，地铁上，周末，不要浪费，不要等碰到比你工作年数还少，比你懂的还多的年轻人时再后悔，当然了，工作再好赚再多的钱也是为了家人，有时间多陪陪家人。\n\n#### 发邮件\n\n公司的事情，不管是新需求，还是需求变更，还是发布更新等等，一律发邮件，开发完成一律邮件回复。不要说他QQ告诉我了我就做了，就走邮件，回头扯不清时有个证据。\n\n#### 写高质量的代码\n\n这个就有点抽象了，什么是高质量的代码，其实也是长期的经验积累的，或者多看看公司的开发规约，代码规范。这个要罗列真是太多了，比如.equals避免空指针，不要在for循环里remove元素等等。该抽取共用方法的抽取共用方法，方便维护，日志要打出要点，不要滥用。注释一定要加，没注释回头自己都不知道什么逻辑了，再没日志的话有问题都不知道哪出的。包括前面提到的写单元测试，等等很多吧，想办法提供代码的健壮性，日后他就不会总出问题来找你，你也就有更多的时间去做其它的事，接口尽量做的通用，再有类似需求你又可以节省很多时间。提高代码的可读性，这样不管谁来接手你的代码，都不要交接，自己看一遍就明白了，同样节省你的时间。 好了，以上就是本人在新公司两个月来总结的经验教训，想到啥写啥，有点乱，分享给大家。","tags":["效率"],"categories":["工作"]},{"title":"Transaction rolled back because it has been marked as rollback-only","url":"/2017/01/22/transaction-rolled-back-because-it-has-been-marked-as-rollback-only/","content":"\n最近项目上用到spring事务时碰到一个问题，报错信息 Transaction rolled back because it has been marked as rollback-only \n<!-- more -->\n现场情况是有两个service：service1，service2；这两个里面都是用的编程式事务，如下。\n```java\ntransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n@Override\nprotected void doInTransactionWithoutResult(TransactionStatus status) {\n//CODE\n}\n});\n```\n如果有异常是以`status.setRollbackOnly() ;`方式回滚; 现在有个biz层bizA调这两个service\n```java\ntransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n@Override\nprotected void doInTransactionWithoutResult(TransactionStatus status) {\nservice1();\nservice2();\n});\n```\n\n要保证这两个service同时成功，有一个回滚了那整体要回滚，因为不是用的注解式的事务，所以同样包了一层,事务嵌套事务 transactionTemplate.execute 结果执行的时候出现了文章开头的错误；最后查阅了资料后终于解决，记录如下： 原因：因为历史原因，service1和service2是对外提供的接口；有错误是以错误码的形式返回的，所以biz层的事务和service层其实是同一个事务，在service层更改了status，而biz层并不知道，还是继续commit，就导致了status非has been marked as rollback-only异常。所以解决方案就是biz层在调用完service后一定要判断下是否成功，不成功的话要在biz层再做一遍status.setRollbackOnly();","tags":["事务"],"categories":["spring"]},{"title":"CentOS6.8通过yum安装mysql5.7","url":"/2017/01/22/centos6-8-yum-install-mysql5-7/","content":"\n#### 前言\ncentos自带的yum安装源，安装mysql版本太低，想安装最新的mysql，手动安装又特别麻烦，网上的各种教程也不知道到底用哪个好，今天在官网找到篇官方的安装[文档](http://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/)，按着操作了一遍，mysql顺利安装，翻译如下分享给大家：\n<!-- more -->\n#### 删除系统自带的mysql\n\n这个文档没写，但要先检查下，执行命令:\n\n`rpm -qa | grep mysql*`\n\n发现有一个自带的_mysql-libs-5.1.73-7.el6.x86_64_ 卸载掉\n\n`yum remove mysql mysql-server mysql-libs compat-mysql51`\n\n#### 安装mysql安装源\n\n打开这个地址[http://dev.mysql.com/downloads/repo/yum/](http://dev.mysql.com/downloads/repo/yum/)，按系统版本需求选择一个下载到CentOS,这里我的是CentOS6.8。选的是_mysql57-community-release-el6-9.noarch.rpm_。执行命令:\n\n`wget http://dev.mysql.com/get/mysql57-community-release-el6-9.noarch.rpm`\n\n然后安装：\n\n`sudo rpm -Uvh mysql57-community-release-el6-9.noarch.rpm`\n\n然后编辑mysql源\n\n`vim /etc/yum.repos.d/mysql-community.repo`\n\n显示如下：\n```\n[mysql-connectors-community]\nname=MySQL Connectors Community\nbaseurl=http://repo.mysql.com/yum/mysql-connectors-community/el/6/$basearch/\nenabled=0\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\n[mysql-tools-community]\nname=MySQL Tools Community\nbaseurl=http://repo.mysql.com/yum/mysql-tools-community/el/6/$basearch/\nenabled=0\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\nEnable to use MySQL 5.5\n\n[mysql55-community]\nname=MySQL 5.5 Community Server\nbaseurl=http://repo.mysql.com/yum/mysql-5.5-community/el/6/$basearch/\nenabled=0\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\nEnable to use MySQL 5.6\n\n[mysql56-community]\nname=MySQL 5.6 Community Server\nbaseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/\nenabled=0\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\n[mysql57-community]\nname=MySQL 5.7 Community Server\nbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\n[mysql80-community]\nname=MySQL 8.0 Community Server\nbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/\nenabled=0\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\n[mysql-tools-preview]\nname=MySQL Tools Preview\nbaseurl=http://repo.mysql.com/yum/mysql-tools-preview/el/6/$basearch/\nenabled=0\ngpgcheck=1\ngpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n```\n我们要安装的是mysql5.7，将_mysql57-community_下的enabled设为1,其他版本enabled设为0.保存，查看当前可安装的mysql,命令：\n\n`yum repolist enabled | grep mysql`\n`mysql57-community MySQL 5.7 Community Server 164`\n\n这时就可以安装了\n\n#### 安装配置mysql\n\n`sudo yum install mysql-community-server`\n\n安装完成后先不要启动，编辑my.cnf文件：\n\n`vim /etc/my.cnf`\n\n在[mysqld]后面加上字符编码utf8\n\n`character_set_server=utf8`\n\n然后启动\n\n`sudo service mysqld start`\n\n启动成功后初始密码放在了mysqld日志文件里\n\n`sudo grep 'temporary password' /var/log/mysqld.log`\n`2017-01-17T15:55:36.100016Z 1 \\[Note\\] A temporary password is generated for root@localhost: g-ra(sLU=5v9`\n\n_g-ra(sLU=5v9_就是初始密码，然后登陆mysql:\n\n`mysql -uroot -p`\n\n输入密码登陆成功后，执行修改密码命令：\n\n`ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass4!';`\n\n注意mysql校验密码复杂度的一个插件是默认安装的，所以设置的密码必要包含大小写字母，数字，字符且最少8个字符。自己设置就可以。然后现在root只能通过localhost连接，想远程连接还要执行命令：\n\n`grant all on *.* to root@'%' identified by '***' with grant option;`\n`flush privileges;`\n\n允许任何ip地址(%表示允许任何ip地址)的电脑用root帐户和密码(**_)来访问这个mysql server。_.*表示库.表，可以设定特定库可以远程访问，防止系统表被远程破坏。ok，可以正常使用了","tags":["mysql"],"categories":["linux"]}]