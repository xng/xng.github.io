{"meta":{"title":"大菜点墨","subtitle":null,"description":null,"author":"大菜","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2018-07-06T02:48:20.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"我是我"},{"title":"categories","date":"2018-07-06T07:43:36.000Z","updated":"2018-07-06T07:43:36.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-07-06T07:44:07.000Z","updated":"2018-07-06T02:49:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java.lang.NoSuchMethodError","slug":"java-lang-nosuchmethoderror","date":"2017-05-13T13:10:07.000Z","updated":"2018-07-06T09:08:28.000Z","comments":true,"path":"2017/05/13/java-lang-nosuchmethoderror/","link":"","permalink":"http://yoursite.com/2017/05/13/java-lang-nosuchmethoderror/","excerpt":"","text":"的最近项目启动遇到一个问题，完整报错信息如下：123Context initialization failedjava.lang.NoSuchMethodError: org.springframework.beans.factory.support.DefaultListableBeanFactory.getDependencyComparator()Ljava/util/Comparator; DefaultListableBeanFactory找不到这个方法getDependencyComparator,先查找这个类到底有没有这个方法，发现这个类出现在两个包里，如下 分别是spring4.和spring2.，很明显是jar包冲突的问题了，一个版本里面有这个方法，另一个没有，把没有的那个版本，一般是低版本，排除掉，再启动，ok了，还有个坑就是这个问题本地用jetty起一直没报出来，上了服务器是tomcat就出来了，可能是择包的机制不一样吧。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"排错","slug":"排错","permalink":"http://yoursite.com/tags/排错/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"node.js入门","slug":"getting-started-with-node-js","date":"2017-03-21T13:27:27.000Z","updated":"2018-07-06T09:08:33.000Z","comments":true,"path":"2017/03/21/getting-started-with-node-js/","link":"","permalink":"http://yoursite.com/2017/03/21/getting-started-with-node-js/","excerpt":"nodejs是什么？ nodejs并不是一门新的语言，Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 谷歌V8又是什么？ V8 是 Google 发布的开源 JavaScript 引擎，采用 C++ 编写，在 Google 的 浏览器中被使用。V8 引擎可以独立运行，也可以用来嵌入到 C++ 应用程序中执行，简单的说就是nodejs是一个JavaScript运行环境，可以让JavaScript运行在服务端，而不是局限于浏览器。依靠谷歌V8引擎解释和执行JavaScript。同时nodejs提供了很多模块，比如http模块，文件读写模块，所以nodejs也是一个库。架构大概如下图","text":"nodejs是什么？ nodejs并不是一门新的语言，Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 谷歌V8又是什么？ V8 是 Google 发布的开源 JavaScript 引擎，采用 C++ 编写，在 Google 的 浏览器中被使用。V8 引擎可以独立运行，也可以用来嵌入到 C++ 应用程序中执行，简单的说就是nodejs是一个JavaScript运行环境，可以让JavaScript运行在服务端，而不是局限于浏览器。依靠谷歌V8引擎解释和执行JavaScript。同时nodejs提供了很多模块，比如http模块，文件读写模块，所以nodejs也是一个库。架构大概如下图 除了使 用 V8 作为JavaScript引擎以外，对不同系统抽象出中间层libuv，实现高性能的异步I/O访问。 为什么使用nodejs? 前面说了nodejs是一个使用了事件驱动，非阻塞式I/O模型，什么非阻塞式I/O模型？ 什么是阻塞，什么是非阻塞？ 阻塞就是你给114打电话问个电话号码，114说你先别挂，等我给你查下，这时候你拿着电话不能去干别的，只能等他查，然后一段时间后告诉你电话号码是啥啥啥？这里你问电话相当于占用了cpu计算，但查电话只是查数据库，有I/O的耗时等待，但并不占用cpu计算，但是呢，你这个cpu现在想去干个别的干不了，还得等这个I/O结束，这就是阻塞，比如Java。非阻塞呢。你给114打电话，114说好的您挂了吧，我查到后告诉你，这时候你可以去干别的了。I/O查询并没有阻塞你，而是I/O（电话）准备好后再通知你,这就是非阻塞。 显而易见非阻塞更合理，就一个单线程，不断的跑计算，遇到io就异步执行，io完成后再继续，但阻塞式编程可以通过多线程去优化，两者流程大概如下: 其实效率差不多，但多线程每个线程都要分配一定的内存，而且我们都知道Java Tomcat是有链接数限制的，异步I/O减少了多线程中创建线程、分配内存、列入调度、切换线程、内存换页、CPU缓存等方面的开销。这个并不是说多线程就不好，各有各的好处吧，如果涉及到大量计算，单线程的cpu会一直被计算占用很难开辟时间去发起I/O操作了。 事件驱动又是怎么回事，上面说的单线程的处理方式其实就是用的事件循环，当执行完计算1后，异步执行了I/O,那cpu知道什么时候继续执行计算2呢，这里看下nodejs的事件循环： nodejs有一个事件队列，然后又一个循环不断的遍历这个队列，里面有事件就去执行，首先计算1是一个事件， 在事件队列里发现后去执行，然后发起了I/O,I/O结束后又会塞一个计算2的事件到事件队列里，再循环的时候就遍历到了，然后执行。 说了这么多，动手试试： 首先要先按钮nodejs，官网自己下载。直接新建个hello.js文件，直接写js就可以。比如在里面写 console.log(‘hello world’)。 控制台用node去执行，node hello.js控制台就会打印出hello world。下面来个复杂点的:1234567891011121314151617181920function cal1() &#123; console.log(\"计算1\") callIO(cal2)&#125;function cal2(data) &#123; console.log(\"计算2结果是\" + data)&#125;function callIO(callback) &#123; console.log(\"IO操作\") setTimeout(function () &#123; console.log(\"IO操作完成查到data是123\") var data = 123; if (callback) &#123; callback(data); &#125; &#125;, 1000)&#125;cal1() 还原了刚才说的计算1–IO–计算2的过程 分析下，执行计算1，中间需要处理I/O了，可能去数据库查了个数据，或者是磁盘读了个文件，也可能是发了个HTTP请求，setTimeOut会js的都明白，这里假装耗时了1秒才完成，执行IO完成后通过IO查到了一个需要计算的data是123，传给计算2去执行计算2，这时候计算2这个事件是调I/O方法时传进来的，这样IO执行完后就把这个事件（计算2）放到了事件队列去执行了。打印如下： 计算1IO操作IO操作完成查到data是123计算2结果是123 之前有人误解说nodejs是单线程的，那哪来的线程去执行IO等操作呢，其实nodejs的单线程是说你写的代码是单线程的，nodejs除了有一个线程去执行你的代码，碰到IO操作会有一个线程池去专门处理这些IO，处理代码的事件循环可以算做主线程。 现在nodejs的基本框架理清了，看下他有哪些常用的API，nodejs有个包管理器，类似Java有个maven库，可以通过pom.xml下载依赖的jar包，配置打包流程等，nodejs也有这么个东西，就是npm，通过配置package.json配置nodejs需要的模块，应用的名字，版本，执行方法等。如下一个例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; \"name\": \"forever\", \"preferGlobal\": \"true\", \"description\": \"A simple CLI tool for ensuring that a given node script runs continuously (i.e. forever)\", \"version\": \"0.15.3\", \"author\": \"Charlie Robbins &lt;charlie.robbins@gmail.com&gt;\", \"maintainers\": [ \"mmalecki &lt;me@mmalecki.com&gt;\", \"avianflu &lt;charlie@charlieistheman.com&gt;\" ], \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/foreverjs/forever.git\" &#125;, \"keywords\": [ \"cli\", \"fault tolerant\", \"sysadmin\", \"tools\" ], \"dependencies\": &#123; \"cliff\": \"~0.1.9\", \"clone\": \"^1.0.2\", \"colors\": \"~0.6.2\", \"flatiron\": \"~0.4.2\", \"forever-monitor\": \"~1.7.0\", \"nconf\": \"~0.6.9\", \"nssocket\": \"~0.5.1\", \"object-assign\": \"^3.0.0\", \"optimist\": \"~0.6.0\", \"path-is-absolute\": \"~1.0.0\", \"prettyjson\": \"^1.1.2\", \"shush\": \"^1.0.0\", \"timespan\": \"~2.3.0\", \"utile\": \"~0.2.1\", \"winston\": \"~0.8.1\" &#125;, \"devDependencies\": &#123; \"broadway\": \"~0.3.6\", \"eventemitter2\": \"0.4.x\", \"request\": \"2.x.x\", \"vows\": \"0.7.x\" &#125;, \"bin\": &#123; \"forever\": \"./bin/forever\" &#125;, \"main\": \"./lib/forever\", \"scripts\": &#123; \"test\": \"vows test/**/*-test.js --spec -i\" &#125;, \"engines\": &#123; \"node\": \"&gt;= 0.8.x\" &#125;, \"license\": \"MIT\"&#125; 这是nodejs众多开发者上传的npm包中的一个叫forever的包的package.json，用来后台运行nodejs应用。看键值就应该明白这个package.json介绍了这个包的名字，版本号，作者，git地址，main方法，依赖的其他包，依赖的nodejs引擎版本还有开源类型。如果你想用这个包，直接npm install forever就行了，node除了开发者上传的包外，自身提供了很多基础的包，比如nodejs内置了http服务器，可以不依赖Tomcat等容器就能启动web服务，如下代码就能启动一个简单的web应用:1234567891011121314const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\\\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 是不是很简单，还有fs文件处理，path路径处理，url链接处理，util工具等包，参考nodejs中文API:http://nodejs.cn/api/ 说了这么多，nodejs适合做什么呢，通过前面介绍他的优缺点可以看出，nodejs适合做高并发，低IO，低计算的应用，比如网络爬虫，实时聊天，前后端分离的应用。不适合做密集型CPU的应用。大概就是这些，后续再补充","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}],"keywords":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"}]},{"title":"程序员用Mac推荐APP","slug":"recommended-programmer-mac-app","date":"2017-01-23T14:48:34.000Z","updated":"2018-07-06T09:08:46.000Z","comments":true,"path":"2017/01/23/recommended-programmer-mac-app/","link":"","permalink":"http://yoursite.com/2017/01/23/recommended-programmer-mac-app/","excerpt":"","text":"不得不说，mac真的是编程利器，如果你不是做window软件开发，不需要玩儿lol等pc游戏，果断用mac吧，基于Unix的操作系统，各种Linux的命令grep,make,top,ssh等都可以直接使用，安全，快速，免除各种驱动烦恼，免除各种安全卫士，精美的设计，当然还有一堆非常好用的app iTerm比Terminal好用的终端，包括选中即复制，command + ; 自动补全命令;command + shift +h 历史命令记录，类似history；智能识别网址，邮箱；tap自动修正等，谁用谁知道； Quiver适合程序员的笔记软件，可以设置代码格式高亮，格式化等。如图 另外支持markdown Cornerstonesvn客户端工具 SourceTreeGit客户端工具 iHosts方便的host切换工具，调试开发必备 QuickMenu方便打开常用目录，可以设置快捷键，在鼠标附近展开菜单，方便点击 Sip 比如我是做前端开发，就用Css Hex取色结果是16进制的颜色码，自动复制到剪贴板，如果做Android开发，选择Android RGB，取色结果就是Color.rgb(35, 40, 45);可以直接在Android使用的颜色代码。Swift UIColor模式结果便是UIColor(red:0.14, green:0.16, blue:0.18, alpha:1.00);非常方便。 Snip腾讯出的一个小工具，支持简单的编辑，非常好用。 Copied保持复制记录，免去重复复制粘贴。包括复制过的图片都有记录 FilleZillaFTP连接工具 Sequal Promysql图形管理工具 等等大概就是这些，其他的IDEA，Sublime Text，Chrome等开发必备的app就不说了，放弃Eclipse吧。。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"程序员如何提高工作效率","slug":"programmers-how-to-improve-work-efficiency","date":"2017-01-22T02:44:57.000Z","updated":"2018-07-06T08:36:51.000Z","comments":true,"path":"2017/01/22/programmers-how-to-improve-work-efficiency/","link":"","permalink":"http://yoursite.com/2017/01/22/programmers-how-to-improve-work-efficiency/","excerpt":"","text":"最近换了换工作了，来到一个国内比较知名的公司，工作两个月后明显感觉到自己之前的不足，这边公司工作不太看重过程，而是看结果，你说作为一个程序员，天天加班来加班去的，不管你多累，没有一个好结果，没用！这里就要想到一个问题，如何提高工作效率？以下是我入职两个月来的工作总结，互利共勉。 不做搬砖工之前来需求，总是人家产品说什么就做什么，一切代码按设计来，一点自己的想法没有，听之任之，回头儿做出一个版本来，产品可能没考虑到实现后的一些问题，又提出要改，这时离上线还有两天了，加班吧！改来改去，感觉身体被掏空，虽然做了很多工作，对结果却没有加成，失败。总结，一定要学会PK,产品来了需求，要打着不做的想法去PK(当然不是为了偷懒)。想一想各种不适合这个需求的场景，提出来，如果能pk过产品，ok，让他去改，改的更合理再做，如果pk不过，那说明需求还算合理，做吧。 多做笔记俗话说好记性不如烂笔头，可能会议记录说了些业务上的事情，你当时缕清了，感觉没难度，过两天开发时，突然又不确定这个流程了，还得跑去找PM问，浪费大家的宝贵时间，所以一定要做好笔记，不管多简单的东西，都记录下来，推荐有道云笔记，mac用户推荐一个软件Quiver，程序员专用。 理清需求来了需求，一定要先梳理清楚再写代码，不要边写边看PRD,弄清楚业务来龙去脉还有细节，比如做个接口，谁来调，怎么调，传递什么参数，一定要提前沟通好，其实每天的工作，写代码的时间很少，大部分时间都在碰需求。需求梳理清楚了，写代码如尿崩分分钟搞定的事情。 磨刀工跟上面缕清需求有点类似，这次是写代码前先弄清代码。什么意思，我还没写呢弄清什么代码？是说你来了一个公司，可能人家的项目已经在运行了，你只是在之前的项目上添加功能，每个项目的框架结构可能不一样。前端的，后端的，一定要弄清楚之前的代码再在上面添加修改。不要觉得他这是这么用的能跑通，我直接复制过来改吧改吧改成我的也能跑通的。这种没弄清代码什么意思就复制粘贴过来隐患最大，千万不要图省事。 授人以渔工作中免不了有新人来请教问题，大家都是新人走过了的，互相帮助是应该的，不过不要有什么问题就直接拿过来调试，或者直接替他写，这样他还是没学会，下次同样的问题还是来找你，应该是指明一个思路，让他自己多想想。这样即让他对这样的问题也增长了经验，也不太耽误自己的工作时间。 不拖延有时分了个任务，自己评估1天就能搞定，给了3天的工期，后面也没啥事，最近又比较累，想想今天就上上网，聊聊天。休息一天吧，这是万万不可取的，有任务，有时间一定要提前完成。计划赶不上变化，你评估的1天有可能3天都玩不成，或者第二天又有个着急的任务扔给你，这时候就要紧张了，提前完成如果后面又有任务可以从容应付，没有新任务想休息下也可以放心休息了。 分轻重开发过程中避免不了遇到各种问题，调试呗，结果为了解决一个小问题调试了一整天，可能调通了，不过这一天就这么浪费了，任务可能还延期了，其实可以这样，有问题，先评估这个问题的轻重，如果不是特别重要，不影响后续的开发，先做主要的事情，回头儿开发完成再来调试，这样不耽误主要的任务进度，如果这个问题解不了后面没法开发，评估一下自己大概多久能解决，如果自己压根儿没思路，就请教请教同事好了，虽然大家都很忙。如果想自己试试，查资料调了半个小时还是没啥进展，还是问问别人吧，不要把一天都浪费在调试上。除了这个我还有选择强迫症，遇到两个框架都能用时就得纠结半天要用哪个。在网上搜罗半天各种分析文章，其实没啥必要，白耽误时间。不要拣了芝麻丢了西瓜。 单元测试DAO接口一定要写单元测试，Service接口有时间的话也写一写，maven打包不要跳过test。团队最好有代码review的习惯，没有的话就找个同事互相review代码。 学习充电如果你像我一样是一个屌丝，家里也没什么背景，别的行业又不感兴趣，励志做一个优秀的程序员，那就抓紧每一分每一秒去学习吧，这个行业真是有学不完的东西，有空闲的时间就看看书，下班回家，地铁上，周末，不要浪费，不要等碰到比你工作年数还少，比你懂的还多的年轻人时再后悔，当然了，工作再好赚再多的钱也是为了家人，有时间多陪陪家人。 发邮件公司的事情，不管是新需求，还是需求变更，还是发布更新等等，一律发邮件，开发完成一律邮件回复。不要说他QQ告诉我了我就做了，就走邮件，回头扯不清时有个证据。 写高质量的代码这个就有点抽象了，什么是高质量的代码，其实也是长期的经验积累的，或者多看看公司的开发规约，代码规范。这个要罗列真是太多了，比如.equals避免空指针，不要在for循环里remove元素等等。该抽取共用方法的抽取共用方法，方便维护，日志要打出要点，不要滥用。注释一定要加，没注释回头自己都不知道什么逻辑了，再没日志的话有问题都不知道哪出的。包括前面提到的写单元测试，等等很多吧，想办法提供代码的健壮性，日后他就不会总出问题来找你，你也就有更多的时间去做其它的事，接口尽量做的通用，再有类似需求你又可以节省很多时间。提高代码的可读性，这样不管谁来接手你的代码，都不要交接，自己看一遍就明白了，同样节省你的时间。 好了，以上就是本人在新公司两个月来总结的经验教训，想到啥写啥，有点乱，分享给大家。","categories":[{"name":"工作","slug":"工作","permalink":"http://yoursite.com/categories/工作/"}],"tags":[{"name":"效率","slug":"效率","permalink":"http://yoursite.com/tags/效率/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"http://yoursite.com/categories/工作/"}]},{"title":"Transaction rolled back because it has been marked as rollback-only","slug":"transaction-rolled-back-because-it-has-been-marked-as-rollback-only","date":"2017-01-22T02:40:49.000Z","updated":"2018-07-06T09:08:57.000Z","comments":true,"path":"2017/01/22/transaction-rolled-back-because-it-has-been-marked-as-rollback-only/","link":"","permalink":"http://yoursite.com/2017/01/22/transaction-rolled-back-because-it-has-been-marked-as-rollback-only/","excerpt":"","text":"最近项目上用到spring事务时碰到一个问题，报错信息 Transaction rolled back because it has been marked as rollback-only 现场情况是有两个service：service1，service2；这两个里面都是用的编程式事务，如下。123456transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;@Overrideprotected void doInTransactionWithoutResult(TransactionStatus status) &#123;//CODE&#125;&#125;); 如果有异常是以status.setRollbackOnly() ;方式回滚; 现在有个biz层bizA调这两个service123456transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;@Overrideprotected void doInTransactionWithoutResult(TransactionStatus status) &#123;service1();service2();&#125;); 要保证这两个service同时成功，有一个回滚了那整体要回滚，因为不是用的注解式的事务，所以同样包了一层,事务嵌套事务 transactionTemplate.execute 结果执行的时候出现了文章开头的错误；最后查阅了资料后终于解决，记录如下： 原因：因为历史原因，service1和service2是对外提供的接口；有错误是以错误码的形式返回的，所以biz层的事务和service层其实是同一个事务，在service层更改了status，而biz层并不知道，还是继续commit，就导致了status非has been marked as rollback-only异常。所以解决方案就是biz层在调用完service后一定要判断下是否成功，不成功的话要在biz层再做一遍status.setRollbackOnly();","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"}],"tags":[{"name":"排错","slug":"排错","permalink":"http://yoursite.com/tags/排错/"},{"name":"事务","slug":"事务","permalink":"http://yoursite.com/tags/事务/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"}]},{"title":"CentOS6.8通过yum安装mysql5.7","slug":"centos6-8-yum-install-mysql5-7","date":"2017-01-22T02:03:53.000Z","updated":"2018-07-06T09:09:14.000Z","comments":true,"path":"2017/01/22/centos6-8-yum-install-mysql5-7/","link":"","permalink":"http://yoursite.com/2017/01/22/centos6-8-yum-install-mysql5-7/","excerpt":"","text":"前言centos自带的yum安装源，安装mysql版本太低，想安装最新的mysql，手动安装又特别麻烦，网上的各种教程也不知道到底用哪个好，今天在官网找到篇官方的安装文档，按着操作了一遍，mysql顺利安装，翻译如下分享给大家： 删除系统自带的mysql这个文档没写，但要先检查下，执行命令: rpm -qa | grep mysql* 发现有一个自带的_mysql-libs-5.1.73-7.el6.x86_64_ 卸载掉 yum remove mysql mysql-server mysql-libs compat-mysql51 安装mysql安装源打开这个地址http://dev.mysql.com/downloads/repo/yum/，按系统版本需求选择一个下载到CentOS,这里我的是CentOS6.8。选的是mysql57-community-release-el6-9.noarch.rpm。执行命令: wget http://dev.mysql.com/get/mysql57-community-release-el6-9.noarch.rpm 然后安装： sudo rpm -Uvh mysql57-community-release-el6-9.noarch.rpm 然后编辑mysql源 vim /etc/yum.repos.d/mysql-community.repo 显示如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[mysql-connectors-community]name=MySQL Connectors Communitybaseurl=http://repo.mysql.com/yum/mysql-connectors-community/el/6/$basearch/enabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql[mysql-tools-community]name=MySQL Tools Communitybaseurl=http://repo.mysql.com/yum/mysql-tools-community/el/6/$basearch/enabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysqlEnable to use MySQL 5.5[mysql55-community]name=MySQL 5.5 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.5-community/el/6/$basearch/enabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysqlEnable to use MySQL 5.6[mysql56-community]name=MySQL 5.6 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/6/$basearch/enabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql[mysql57-community]name=MySQL 5.7 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/6/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql[mysql80-community]name=MySQL 8.0 Community Serverbaseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/6/$basearch/enabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql[mysql-tools-preview]name=MySQL Tools Previewbaseurl=http://repo.mysql.com/yum/mysql-tools-preview/el/6/$basearch/enabled=0gpgcheck=1gpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 我们要安装的是mysql5.7，将mysql57-community下的enabled设为1,其他版本enabled设为0.保存，查看当前可安装的mysql,命令： yum repolist enabled | grep mysqlmysql57-community MySQL 5.7 Community Server 164 这时就可以安装了 安装配置mysqlsudo yum install mysql-community-server 安装完成后先不要启动，编辑my.cnf文件： vim /etc/my.cnf 在[mysqld]后面加上字符编码utf8 character_set_server=utf8 然后启动 sudo service mysqld start 启动成功后初始密码放在了mysqld日志文件里 sudo grep &#39;temporary password&#39; /var/log/mysqld.log2017-01-17T15:55:36.100016Z 1 \\[Note\\] A temporary password is generated for root@localhost: g-ra(sLU=5v9 g-ra(sLU=5v9就是初始密码，然后登陆mysql: mysql -uroot -p 输入密码登陆成功后，执行修改密码命令： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;; 注意mysql校验密码复杂度的一个插件是默认安装的，所以设置的密码必要包含大小写字母，数字，字符且最少8个字符。自己设置就可以。然后现在root只能通过localhost连接，想远程连接还要执行命令： grant all on *.* to root@&#39;%&#39; identified by &#39;***&#39; with grant option;flush privileges; 允许任何ip地址(%表示允许任何ip地址)的电脑用root帐户和密码(*)来访问这个mysql server。.表示库.表，可以设定特定库可以远程访问，防止系统表被远程破坏。ok，可以正常使用了","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}]}]}